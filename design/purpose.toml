[REQ-0]
text = "definitions and process for the artifact project"

[REQ-0-assertions]
text = '''
Assertions **will** be used throughout the artifacts to mean:
- shall: the statement must be implemented and it's
    implementation verified.
- will: statement of fact, not subject to verification.
    i.e. "The X system will have timing as defined in ICD 1234"
- should: goals, non-mandatory provisions. Statements using "should"
    **should** be verified if possible, but verification is not mandatory if
    not possible. Should is a statement of intent
'''

[REQ-0-format]
text = '''
**artifact** **will** use a simple text format for the user to write artifacts in
'''

[REQ-0-language]
text = "a programming language must be chosen to write the project in"

[REQ-0-prefix]
text = '''
In this project, the following conventions shall apply for artifact names:
 - `ART-0-*` denotes definitions and artifact process only. These will be defined
     as completed, as they are simply documenting the process of artifacts.
 - `ART-1-*` denotes purpose REQs, which detail at the highest level why
     this project exists
 - `ART-2-*` denotes high level design of all artifacts (req, spc, artifact and tst)
 - further prefixes **will not** be used, and are reserved for further breakdowns
 - any other prefix denotes detailed design. For instance, REQ-0-load details what is necessary in
     loading artifacts at a very high level, wheras REQ-load details it at a lower level

Any artifact that is `1` or `2` **will not** be implemented in code (it will only be implemented
by sub artifacts)

The purpose of this prefix is to bring these artifacts to the top when they are listed,
as well as make a simple and clear distinction between high and low level design
'''

[REQ-0-risks]
text = '''
Risks are to be written with three sets of terms in mind:
- likelyhood
- impact
- product placement

likelyhood has three categores:
 1. low
 2. medium
 3. high

impact has five categories:
 1. sand
 2. pebble
 3. rock
 4. boulder
 5. avalanche

product placement has three categores:
 1. cosmetic
 3. necessary
 5. critical

The value of these three categoires will be multiplied to
determine the weight to assign to the risk.

> sand may seem small, but if you have enough sand in your
> gears, you aren't going anywhere.
>
> You definitely need to watch out for boulders and prevent
> avalanches whenever possible
'''

[REQ-1]
text = '''
purpose requirements. For an easy-to-read purpose statement see:
[README.md](https://github.com/vitiral/artifact/blob/master/README.md)
'''

[REQ-1-artifact]
text = '''
artifact **will** support 4 types of artifacts that can be tracked
- REQ: software requirement
- RSK: risks related to requirements
- SPC: software design specificaion based on one or more requirements
- TST: test design of a risk or specification

The valid links **will** look like this:
```
  REQ <-- SPC* <-- TST*
   ^                |
    \---- RSK <-----/

* SPC and TST can be implemented at a location or a link
```

In other words, you can design a spec (SPC) based on
a requirement (REQ). A requirement can have a risk (RSK)
associated with it. Tests can test to either a spec (SPC)
or to a risk (RSK)

The artifacts **will** have simple orthoganl variables that accomplish
the purposes defined in REQ-purpose.
'''

[REQ-1-cmd]
partof = "REQ-1-ui"
text = '''
artifact's primarily purpose **should** be to support text based and cmdline
workflows. artifact **will** provide a cmd line utilitie to use artifact features,
view and filter artifacts, etc.

The commands on the cmdline **will** be memonic and borrow from other
common command line tools like bash, git, etc whenever possible.
'''

[REQ-1-coverage]
text = '''
artifact **will** provide a simple but useful mechanism for calculating
and displaying implementation and test coverage / completeness
'''

[REQ-1-interop]
text = '''
artifact **will** provide simple methods for other tools to interact with
it's data
'''

[REQ-1-linking]
partof = "REQ-1-[artifact, coverage]"
text = '''
linking **will** be in an easy to understand format.

linking should be possible:
- between artifacts
- with the location of implementation

It is recognized that there are two main concerns:
- ease of writing links
- ease of reading links

Ease of writing links is considered the most important, as reading
links can be accomplished automatically through the ui interface.

For this reason, **artifact** uses the "partof" nomenclature for linking.
This allows the user to think "what requirement does this fulfill"
or "what requirement is this a risk for" and link things one at a time.

**artifact** does not provide the "parts" nomenclature, as having both would
add needless complexity.

In addition, **artifact** will try to infer links from the names whenever possible.
'''

[REQ-1-scale]
text = '''
artifact **will** be able to handle scale from very small projects with a single
design document to enourmous multi-project multi-folder projects.
'''

[REQ-1-ui]
text = '''
artifact **will** provide simple methods to interact and view it's data
'''

[REQ-1-variables]
text = '''
there **will** be a method of setting global and local variables
for use in text and paths
'''

[REQ-1-versioning]
text = '''
artifact **should** never make a breaking change once a version has been
declared stable.

In the event a breaking change is necessary, artifact **shall** not make the
change until a major version release and shall attempt whatever backwards
compatibility is possible.
'''

[REQ-1-tracker]
text = '''
artifact **shall** have test tracking functionality that will enable projects
and orginizations to track continuously running integration tests.

Unlike the rest of artifact, this tool **shall not** store it's results in text,
as that would be a tracking, performance and extendability nightmare.
Instead it should use a database backend and be run through the `serve`
subcommand along with the web-ui.

The data that needs to be stored by the test tracking tool is:
 - test name (i.e. MyTest2)
 - design artifacts it tests (i.e. [TST-foo-bar, TST-baz-boo])
 - timestamp of test
 - version that was tested 
    (i.e. 3.2.3.4 commit=154642d49b393e49d9de987685335e9c5a8b2aa7)
 - url/path to view test results and data externally
 - extra binary data

All of this should be kept in a database (probably PostgreSQL)
and be easily searchable.

All of the data shall be accessible through artifact's json-rpc server
endpoint (the same one that hosts and supports the web-ui).

In addition, a section of the web-ui shall be dedicated to viewing
test results, and test artifacts shall include links to their test
data (if it exists). Test results should be easy to filter, graph
, compare and generate reports for in the UI.
'''

[REQ-1-web]
partof = "REQ-1-ui"
text = '''
artifact **shall** provide a web-based frontend who's ui will leverage
web-specific technology
'''

[SPC-0-done]
partof = "REQ-0-[assertions, prefix, risks], SPC-0-[format, language]"
text = "This document itself meets the requirements of the definitions and process"

[SPC-0-format]
text = '''
Possible choices:
 - json: decent but too general for the purpose (nesting is unnecessary)
     also, no way to line-comment making it almost useless for a tracking
     tool. Also, not readable enough.
 - ini/toml: both are decent formats, prefer toml as it is a little bit
     simpler
 - yaml: too complex for what is needed, not as readable as ini. Very
     enjoyable general purpose format.
 - html/xml/etc: aboslutely not. Needlessly complex.

# Conclusion
`artifact` **shall** use TOML for artifact writing.

The reasons are:
 - feautres covers all needs for artifact
 - easy to learn
 - easy to read
 - easy to write in
 - feature set well-limited to this application (not too many
     features or way to do the same thing)
'''

[SPC-0-language]
text = '''
artifact **will** be written entirely in the rust programming language
for the purposes of:
- cross compilation: rust can be compiled on any platform
- safety: it is impossible to segfault in rust
- speed: rust is as fast as C++
- static checking: rust is one of the most powerful static type checking
    languages in existence, making it easier to refactor code
- scale-out: single threaded code can easily be made highly concurrent
- fun: rust is a fun language to write in.
'''

[SPC-1-versioning]

[TST-0-done]
partof = "SPC-[0, 0-[format, language]]"
text = "no tests necessary on definitions and process"

[TST-1-versioning]
