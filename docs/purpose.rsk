[REQ-purpose]
refs = ["{repo}/README.md"]

[REQ-purpose-scale]
text = '''
rsk **will** be able to handle scale from very small projects with a single
design document to enourmous multi-project multi-folder projects.
'''

[REQ-purpose-definitions]
text = '''
rsk **will** use defined definitions for all potentially confusing terms
'''

[REQ-purpose-coverage]
text = '''
rsk **will** provide a simple but useful mechanism for calculating
and displaying implementation and test coverage / completeness
'''

[REQ-purpose-artifacts]
text = '''
rsk **will** support 5 types of artifacts that can be tracked
- REQ: software requirement
- RSK: risks related to requirements
- SPC: software design specificaion based on one or more requirements
- TST: test design of a risk or specification

The valid links **will** look like this:
```
  REQ <-- SPC* <-- TST*
   ^                |
    \---- RSK <-----/

* SPC and TST can be implemented at a location or a link
```

In other words, you can design a spec (SPC) based on
a requirement (REQ). A requirement can have a risk (RSK)
associated with it. Tests can test to either a spec (SPC)
or to a risk (RSK)

The artifacts **will** have simple orthoganl variables that accomplish
the purposes defined in REQ-purpose.
'''

[REQ-purpose-format]
text = '''
**rsk** **will** use a simple text format to structure it's files

Possible choices:
- json: decent but too general for the purpose (nesting is unnecessary)
    also, no way to line-comment making it almost useless for a tracking
    tool. Also, not readable enough.
- ini/toml: both are decent formats, prefer toml as it is a little bit
    simpler
- yaml: too complex for what is needed, not as readable as ini. Very
    enjoyable general purpose format.
- html/xml/etc: aboslutely not. Needlessly complex.
'''

[REQ-purpose-linking]
partof = "REQ-purpose-[artifacts, coverage]"
text = '''
linking **will** be in an easy to understand format.

linking should be possible:
- between artifacts
- with the location of implementation

It is recognized that there are two main concerns:
- ease of writing links
- ease of reading links

Ease of writing links is considered the most important, as reading
links can be accomplished automatically through the ui interface.

For this reason, **rsk** uses the "partof" nomenclature for linking.
This allows the user to think "what requirement does this fulfill"
or "what requirement is this a risk for" and link things one at a time.

**rsk** does not provide the "parts" nomenclature, as having both would
add needless complexity.
'''

[REQ-purpose-variables]
text = '''
there **will** be a method of setting global and local variables
for use in text and paths
'''

[REQ-purpose-ui]
text = '''
rsk **will** provide simple methods to interact and view it's data
'''

[REQ-purpose-ui-cmdline]
text = '''
rsk **will** provide cmd line utilities to view summaries and specific
artifacts

rsk's primarily purpose **should** be to support text based and cmdline
workflows
'''

[REQ-purpose-ui-filtering]
text = '''
rsk's various ui methods **will** provide methods to filter by:
- percent completed
- percent tested
'''

[REQ-purpose-ui-markdown]
text = '''
when displaying to the user, all text **will** be processed
as a simple markdown format
'''

[REQ-purpose-ui-link]
text = '''
rsk's various ui methods **will** provide simple methods to
navigate and view linked components
'''

[REQ-purpose-ui-html]
text = '''
rsk **will** provide the ability to export to static-html for web-broswing
of information
'''

[REQ-purpose-interop]
text = '''
rsk **will** provide simple methods for other tools to interact with
it's data
'''

[REQ-purpose-interop-json]
text = '''
rsk **will** provide json export utility for other tools to utilize.

rsk **will** not utilize the exported json.
'''

[REQ-purpose-interop-sql]
text = '''
Later impleemntations of rsk **will** utilize an sql database to improve
speed and interopability with external tooling.

This database will probably be sqlite to meet with rsk's simplicity
of requirements and **will** be optional for users.
'''

[REQ-purpose-etc-language]
text = '''
rsk **will** be written entirely in the rust programming language
for the purposes of:
- speed: rust is as fast as C++ (or faster)
- cross compilation: rust can be compiled on any platform
- safety: it is impossible to segfault in rust
- static checking: rust is one of the most powerful static type checking
languages in existence
- scale-out: single threaded code can easily be made highly concurrent 
- fun: rust is a fun language to write in.
'''
[SPC-purpose-etc-language]
partof = "REQ-purpose-etc-language"
loc = "{cwd}/notes.md"
[TST-purpose-etc-language]
partof = "SPC-purpose-etc-language"
loc = "{cwd}/notes.md"

[REQ-purpose-etc-modules]
text = '''
rsk **should** have decoupled modules that depend on eachother as little
as possible.

Roughly, they **should** be broken up according to these requirements.
'''
[SPC-purpose-etc-modules]
partof = "REQ-purpose-etc-modules"
loc = "{cwd}/notes.md"
[TST-purpose-etc-modules]
partof = "SPC-purpose-etc-modules"
loc = "{cwd}/notes.md"

[REQ-purpose-versioning]
text = '''
rsk **should** never make a breaking change once a version has been
declared stable.

In the event a breaking change is necessary, rsk **shall** not make the
change until a major version release and shall attempt whatever backwards
compatibility is possible.
'''
[SPC-purpose-etc-versioning]
partof = "REQ-purpose-versioning"
loc = "{cwd}/notes.md"
[TST-purpose-etc-versioning]
partof = "SPC-purpose-etc-versioning"
loc = "{cwd}/notes.md"
