# Welcome to the rsk tutorial! This file is written in a way that
# your .rsk files can be written in to define your requirements
# and design specifications.
#
# get to this stage in the tutorial at any time with:
#
#     rsk tutorial
#
# rsk is a command line, text based tool for requriements tracking.
# It aims to be easy to use by anybody and especially productive
# for developers
#
# Follow along with this file to get an idea of how you can
# easily write and track requirements in your source code
#
# before we continue too far, why don't you try a command? Type
# the following command:
#
#     rsk ls SPC-learn-ls -l
#
# You should see a colorized artifact that is a partof of a few other
# artifacts. If you do, good. If you are having problems try going back to
# the installation tutorial.
# Run `rsk ls -h` and try a few other commands to get a feel for the interface.

##################################################
# Defining requirements

[REQ-toml]
text = '''
.rsk files like this one are written in the TOML format
you can read more about it here: https://github.com/toml-lang/toml

all rsk files must end in ".rsk"

They are all flat. This means rsk does not support the "[first.second]"
syntax. This means that the "." character is illegal in names
'''

[REQ-learn-rsk]
text = '''
artifacts are defined by specifying their name like so: "[REQ-NAME]"

Artifacts can be a requirement (REQ), design-specification (SPC)
risk (RSK) or test (TST)

This particular artifact is a requirement, therefore it begins with
"REQ" After REQ there is a "-" and then the name of the requirement.

Unlike many requirements tracking tools, rsk encourages the use
of human-readable names. We will talk more about this later.
'''

[SPC-learn-spc]
text = '''
This is a design specification and is automatically linked as a "partof"
REQ-learn-rsk because it has the same name. In addition, it is a partof
REQ-toml because it was explicitly linked using the "partof" field.
'''

[REQ-learn-partof]
text = "see the next artifact"

[SPC-learn-partof]
partof = "REQ-learn-rsk"
text = '''
RSK uses the names of artifacts to automatically link them and track progress
as well as makes it simple for the user to link to arbitrary artifacts.
(but they must be of specific types, more on that later)

REQ-learn-rsk is explicitly a "partof" this artifact because it is specified
explicitly.

REQ-learn-partof is automatically a partof this artifact because the names
after the type are the same.

In addition, missing parents are automatically created and linked. So
SPC-LEARN is also a partof this artifact, even though it is not even in this
document. This makes it very easy to make trees of artifacts without needing to
specify every branch.

So far we have:

REQ <-- REQ-LEARN <-- REQ-LEARN-PARTOF <-- SPC-learn-partof
           ^                                  |
            \\---------REQ-learn-partof <------/

(Note: only parents are created automatically. Auto-creating for similar-named
  artifacts would polute your links)
'''

[SPC-learn-example]
text = "this is used in the next artifact"

[TST-learn-partof]
partof = "SPC-learn-[spc, example]"
text = '''
The partof field is a string that uses a simple grouping syntax. This example
does as you would expect, this artifact is a partof SPC-learn-spc and SPC-learn-example

note: it is also automatically a partof SPC-learn-partof and TST-LEARN because of the name
'''

[TST-learn-valid]
partof = "SPC-learn-partof"
text = '''
There are some rules for which artifacts can be a partof other artifacts:
- all artifacts can be a partof their own group (i.e. SPC partof SPC)
- SPC can be a partof REQ
- RSK can be a partof REQ
- TST can be a partof SPC or RSK
- REQ can only be a partof itself

Here is a helpful graph of valid relations:
  REQ <-- SPC* <-- TST*
   ^                |
    \\---- RSK <-----/

In other words, you can design a spec (SPC) based on
a requirement (REQ). A requirement can have a risk (RSK)
associated with it. Tests can test to either a spec (SPC)
or to a risk (RSK)

[SPC-learn-paths]
text = '''
in the {repo}/.rsk/settings.rsk file you must define the path where you want
to put your artifacts. This path will be searched recursively but will stop
at the first directory where there is not a .rsk file.

There are only a few rules for defining artifacts:
 - case is ignored for all names (except globals and settings)
 - names cannot overlap, even in different files
 - artifacts must follow TST-learn-valid (see above)
 - all items (i.e. [REQ-foo]) must start with either REQ, RSK, SPC or TST
     *except* for "globals" and "settings"
'''

[SPC-learn-ls]
text = '''
The `ls` command is the most important component to learn in rsk, as it helps you
manage the artifacts in your project, view how completed/tested they are,
see how they are linked.

Type:
    rsk ls SPC-learn-ls -l

This will show you this artifact, pretty printed on your terminal.

Try:
    rsk ls learn -p

This searches in the "Name" field for all artifacts that have "learn"
in their name.

Let's say you wanted to find an artifact, and all you knew was that it mentioned files
in it's text field. You could run:

    rsk ls file -p T -T

This will search for the pattern "file" in the text field (`-p T`). It will also display a
short piece of the text field (`-T`)

Now let's say that You see that SPC-learn-paths is what you were looking for,
but you want an expanded view:

   rsk ls SPC-learn-paths -l

Now you see that SPC-learn-paths has not been tested or implemented and that it is partof
SPC-LEARN. From this you could decide what to do.
'''

##################################################
# That is the end of this tutorial. Run the following
# for part 2:
#     rsk tutorial 2
